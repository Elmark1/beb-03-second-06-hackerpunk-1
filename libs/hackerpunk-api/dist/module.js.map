{"mappings":"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","sources":["src/index.ts","src/lib/wallet.ts","src/lib/HP.ts","src/lib/HPTimeLock.ts","src/lib/ExternalHP.ts","src/lib/provider.ts"],"sourcesContent":["import { createWallet } from \"./lib/wallet\";\nimport { HP } from \"./lib/HP\";\nimport { HPTimeLock } from \"./lib/HPTimeLock\";\nimport { ExternalHP } from \"./lib/ExternalHP\";\nimport { setProvider, setWallet, setSigner } from \"./lib/provider\";\n\nexport {\n  HP,\n  HPTimeLock,\n  ExternalHP,\n  setProvider,\n  setWallet,\n  setSigner,\n  createWallet,\n};\n","import * as lightwallet from \"eth-lightwallet\";\n\n/**\n * @method: returns address and privateKey\n * @param {string} pwd user password\n * @return {Promise} object of address, privateKey and mnemonic\n */\nconst createWallet = (pwd: string): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    let secretSeed: string = lightwallet.keystore.generateRandomSeed();\n\n    lightwallet.keystore.createVault(\n      {\n        password: pwd,\n        seedPhrase: secretSeed,\n        hdPathString: \"m/0'/0'/0'\",\n      },\n      (err, ks) => {\n        if (err) reject(err);\n        ks.keyFromPassword(pwd, (err, pwDeriveKey) => {\n          if (err) reject(err);\n          ks.generateNewAddress(pwDeriveKey, 1);\n\n          let address = ks.getAddresses().toString();\n          let privateKey = ks.exportPrivateKey(address, pwDeriveKey);\n\n          resolve({ address, privateKey, mnemonic: secretSeed });\n        });\n      }\n    );\n  });\n};\n\nexport { createWallet };\n","import { ethers } from \"ethers\";\n\nclass HP {\n  contract: ethers.Contract;\n  contractAddress: string;\n  abi: ethers.ContractInterface;\n\n  constructor(\n    signer: ethers.Signer,\n    contractAddress: string,\n    abi: ethers.ContractInterface\n  ) {\n    this.contractAddress = contractAddress;\n    this.abi = abi;\n    this.contract = new ethers.Contract(this.contractAddress, this.abi, signer);\n  }\n\n  /**\n   * @method change signer of contract\n   * @param signer\n   */\n  async changeContractSigner(signer: ethers.Signer) {\n    this.contract = this.contract.connect(signer);\n  }\n\n  /**\n   * @method initial minting once, only admin\n   */\n  async init() {\n    await this.contract.init();\n  }\n\n  /**\n   * @method enable ExternalHP Contract to mint\n   */\n  async grantMinterRole(contract: string) {\n    await this.contract.grantMinterRole(contract);\n  }\n\n  /**\n   * @method set signup token reward, only admin\n   */\n  async setSignupReward(signupReward: number) {\n    await this.contract.setSignupReward();\n  }\n\n  /**\n   * @method set attendacne token reward, only admin\n   */\n  async setAttendanceReward(attendanceReward: number) {\n    await this.contract.setAttendanceReward();\n  }\n\n  /**\n   * @method mint token to reward signup, only minter\n   */\n  async signupMint(recipient: string) {\n    await this.contract.signupMint();\n  }\n\n  /**\n   * @method mint token to reward attendacne, only minter\n   */\n  async attendanceMint(recipient: string) {\n    await this.contract.attendacneMint();\n  }\n\n  /**\n   * @method mint token to reward users at once, only minter\n   */\n  async attendanceMintBatch(recipients: string[]) {\n    await this.contract.attendanceMintBatch();\n  }\n\n  /**\n   * @method check balance of user\n   */\n  async balanceOf(user: string): Promise<number> {\n    return await this.contract.balanceOf(user);\n  }\n}\n\nexport { HP };\n","import { HP } from \"../../dist/types\";\nimport { ethers } from \"ethers\";\n\nclass HPTimeLock {\n  contract: ethers.Contract;\n  contractAddress: string;\n  abi: ethers.ContractInterface;\n\n  constructor(\n    signer: ethers.Signer,\n    contractAddress: string,\n    abi: ethers.ContractInterface\n  ) {\n    this.contractAddress = contractAddress;\n    this.abi = abi;\n    this.contract = new ethers.Contract(this.contractAddress, this.abi, signer);\n  }\n\n  /**\n   * @method change signer of contract\n   * @param signer\n   */\n  async changeContractSigner(signer: ethers.Signer) {\n    this.contract = this.contract.connect(signer);\n  }\n\n  /**\n   * @returns 0: not started, 1: proceeding 2: complete, 3: reverted\n   */\n  async checkDonationStatus(articleId: number): Promise<number> {\n    return await this.contract.checkDonationStatus(articleId);\n  }\n\n  async getDonators(articleId: number): Promise<string[]> {\n    return await this.contract.getDonators(articleId);\n  }\n\n  async getDonationBalance(articleId: number): Promise<number> {\n    return await this.contract.getDonationBalance(articleId);\n  }\n\n  /**\n   * @method donator approve donation token to HPTimeLock contract and then, this token locked, only owner\n   * @param hp HP's Contract should be connected to donator's signer\n   */\n  async donate(\n    hp: HP,\n    articleId: number,\n    donator: string,\n    writer: string,\n    amount: number\n  ) {\n    await hp.contract.approve(this.contract.address, amount);\n    await this.contract.donate(articleId, donator, writer, amount);\n  }\n\n  /**\n   * @method article removed, all token donated are returned to donators, only owner\n   */\n  async revokeAll(articleId: number, writer: string) {\n    await this.contract.revokeAll(articleId, writer);\n  }\n\n  /**\n   * @method donator revoke donation and token returned, only owner\n   */\n  async revokeDonate(articleId: number, donator: string) {\n    await this.contract.revokeDonate(articleId, donator);\n  }\n\n  /**\n   * @method donation token released to writer after lock time, only owner\n   */\n  async release(articleId: number, writer: string) {\n    await this.contract.release(articleId, writer);\n  }\n}\n\nexport { HPTimeLock };\n","import { ethers } from \"ethers\";\n\nclass ExternalHP {\n  contract: ethers.Contract;\n  contractAddress: string;\n  abi: ethers.ContractInterface;\n\n  constructor(\n    signer: ethers.Signer,\n    contractAddress: string,\n    abi: ethers.ContractInterface\n  ) {\n    this.contractAddress = contractAddress;\n    this.abi = abi;\n    this.contract = new ethers.Contract(this.contractAddress, this.abi, signer);\n  }\n\n  /**\n   * @method change signer of contract\n   * @param signer\n   */\n  async changeContractSigner(signer: ethers.Signer) {\n    this.contract = this.contract.connect(signer);\n  }\n\n  async signupFee(): Promise<number> {\n    return await this.contract.signupFee();\n  }\n\n  /**\n   * @method onlyOwner\n   */\n  async getAllServerAccounts(): Promise<string[]> {\n    return await this.contract.getAllServerAccounts;\n  }\n\n  /**\n   * @method onlyOwner\n   */\n  async setSignupFee(fee: number) {\n    await this.contract.setSignupFee(fee);\n  }\n\n  /**\n   * @method External account send transaction fee and get amount of HP token to be registered\n   * @param serverAccount\n   * @param fee signupfee\n   */\n  async registerExternal(serverAccount: string, fee: number) {\n    await this.contract.registerExternal(serverAccount, { from: fee });\n  }\n}\n\nexport { ExternalHP };\n","import { ethers } from \"ethers\";\n\n/**\n * @param network default mainnet, can be url like http or wss\n * @param provider etherscan, infura, alchemy, etc...\n * @param key apikey, in case of infura project_id\n * @returns provider or Error\n */\nexport const setProvider = (\n  network: string,\n  provider?: string,\n  key?: string\n): ethers.providers.BaseProvider | Error => {\n  if (network === undefined) return ethers.getDefaultProvider();\n  else {\n    if (network.startsWith(\"wss\") || network.startsWith(\"http\"))\n      return ethers.getDefaultProvider(network);\n    else {\n      if (provider !== undefined) {\n        const options = {\n          [provider]: key,\n        };\n\n        return ethers.getDefaultProvider(network, options);\n      } else {\n        return new Error(\"provider is not correct\");\n      }\n    }\n  }\n};\n\n/**\n * @method make crypto wallet\n * @param privateKey string\n * @returns wallet\n */\nexport const setWallet = (privateKey: string): ethers.Wallet => {\n  return new ethers.Wallet(privateKey);\n};\n\n/**\n * @method connect provider to wallet\n * @param wallet\n * @param provider\n * @returns signer\n */\nexport const setSigner = (\n  wallet: ethers.Wallet,\n  provider: ethers.providers.BaseProvider\n): ethers.Signer => {\n  return wallet.connect(provider);\n};\n"],"names":[],"version":3,"file":"module.js.map"}